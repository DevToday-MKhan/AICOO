import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { getRouteQuote } from "./routing.js";
import { assignDelivery } from "./delivery.js";
import { recordEvent, saveShopifyOrder } from "./webhooks.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SIMULATIONS_FILE = path.join(__dirname, "data", "simulations.json");

/**
 * AICOO Order Simulation Engine
 * Test routing, delivery, memory, and events without real Shopify webhooks
 */

// Load simulation history
function loadSimulations() {
  try {
    if (!fs.existsSync(SIMULATIONS_FILE)) {
      fs.writeFileSync(SIMULATIONS_FILE, "[]");
      return [];
    }
    const data = fs.readFileSync(SIMULATIONS_FILE, "utf8");
    return JSON.parse(data);
  } catch (error) {
    console.error("âŒ Failed to load simulations:", error.message);
    return [];
  }
}

// Save simulation to history
function saveSimulation(simulation) {
  try {
    const simulations = loadSimulations();
    simulations.push(simulation);
    
    // Keep only last 50 simulations
    const trimmed = simulations.slice(-50);
    fs.writeFileSync(SIMULATIONS_FILE, JSON.stringify(trimmed, null, 2));
    
    return true;
  } catch (error) {
    console.error("âŒ Failed to save simulation:", error.message);
    return false;
  }
}

// Generate fake order payload
export function generateFakeOrder(zip, weight, totalPrice = null) {
  const orderId = Date.now();
  const calculatedPrice = totalPrice || (weight * 25.99); // $25.99 per lb
  
  return {
    id: orderId,
    order_number: orderId,
    email: `test-${orderId}@simulation.local`,
    created_at: new Date().toISOString(),
    total_price: calculatedPrice.toFixed(2),
    subtotal_price: calculatedPrice.toFixed(2),
    total_weight: weight,
    financial_status: "paid",
    fulfillment_status: null,
    customer: {
      id: Math.floor(Math.random() * 100000),
      email: `test-${orderId}@simulation.local`,
      first_name: "Test",
      last_name: "User",
    },
    shipping_address: {
      zip: zip,
      city: "Test City",
      province: "NY",
      country: "United States",
      address1: "123 Test St",
    },
    line_items: [
      {
        id: orderId + 1,
        title: "Simulated Chicken Product",
        quantity: 1,
        price: calculatedPrice.toFixed(2),
        grams: weight * 453.592, // Convert lbs to grams
        sku: `SIM-CHICKEN-${weight}LB`,
      },
    ],
    note: "ðŸ§ª SIMULATED ORDER - Generated by AICOO Simulator",
    tags: "simulation, test, aicoo",
  };
}

// Run full simulation pipeline
export async function runFullPipeline(orderPayload) {
  const simulationId = Date.now();
  const startTime = new Date();
  
  console.log(`ðŸ§ª Starting simulation #${simulationId}`);
  
  const result = {
    simulationId,
    timestamp: startTime.toISOString(),
    order: orderPayload,
    routing: null,
    delivery: null,
    memory: null,
    events: [],
    errors: [],
    success: false,
  };

  try {
    // Step 1: Parse order details
    const customerZip = orderPayload.shipping_address?.zip || orderPayload.customer_zip;
    const totalWeight = orderPayload.total_weight || orderPayload.weight || 5;
    const orderId = orderPayload.id || orderPayload.order_number;

    if (!customerZip) {
      throw new Error("Missing customer ZIP code in order payload");
    }

    console.log(`ðŸ“ Order ${orderId} â†’ ZIP ${customerZip}, Weight ${totalWeight} lbs`);

    // Step 2: Save order (simulates webhook processing)
    try {
      saveShopifyOrder(orderPayload);
      recordEvent({ event_type: "simulation_order_created", data: { orderId, customerZip } });
      result.events.push("order_created");
    } catch (err) {
      console.warn("âš ï¸  Order save failed:", err.message);
    }

    // Step 3: Get routing quote
    console.log(`ðŸ—ºï¸  Calculating route for ZIP ${customerZip}...`);
    const routeQuote = getRouteQuote({ customerZip, weight: totalWeight });
    result.routing = routeQuote;
    result.events.push("routing_calculated");

    // Step 4: Assign delivery
    console.log(`ðŸšš Assigning delivery method...`);
    const delivery = assignDelivery({
      orderId,
      customerZip,
      weight: totalWeight,
      routing: routeQuote,
    });
    result.delivery = delivery;
    result.events.push("delivery_assigned");

    // Step 5: Record in memory (routing and delivery already auto-recorded)
    console.log(`ðŸ§  Recording simulation observation...`);
    try {
      const memoryModule = await import("./memory.js");
      memoryModule.addObservation("simulation_completed", {
        simulationId,
        orderId,
        routingMethod: routeQuote.bestMethod,
        deliveryService: delivery.service || delivery.carrier,
        deliveryPrice: delivery.price,
      });
      
      result.memory = {
        observationRecorded: true,
        autoRecorded: "routing and delivery auto-recorded via modules"
      };
    } catch (memErr) {
      console.warn("âš ï¸  Memory recording skipped:", memErr.message);
      result.memory = { error: memErr.message };
    }

    result.events.push("memory_updated");
    result.success = true;

    console.log(`âœ… Simulation #${simulationId} completed successfully`);
    console.log(`   â†’ Routing: ${routeQuote.bestMethod}`);
    console.log(`   â†’ Delivery: ${delivery.service || delivery.carrier} ($${delivery.price})`);

  } catch (error) {
    console.error(`âŒ Simulation #${simulationId} failed:`, error.message);
    result.errors.push(error.message);
    result.success = false;
  }

  // Save simulation to history
  saveSimulation(result);

  return result;
}

// Simulate order from payload
export async function simulateOrder(payload) {
  console.log("ðŸ§ª Running order simulation...");
  return await runFullPipeline(payload);
}

// Replay existing order by ID
export async function replayOrder(orderId) {
  console.log(`ðŸ”„ Replaying order ${orderId}...`);
  
  // Load orders from storage
  const ordersPath = path.join(__dirname, "data", "orders.json");
  
  try {
    const ordersData = fs.readFileSync(ordersPath, "utf8");
    const orders = JSON.parse(ordersData);
    
    // Find order by ID
    const order = orders.find(o => o.id == orderId || o.order_number == orderId);
    
    if (!order) {
      throw new Error(`Order ${orderId} not found in storage`);
    }

    console.log(`âœ… Found order ${orderId}, replaying...`);
    return await runFullPipeline(order);
    
  } catch (error) {
    console.error(`âŒ Replay failed for order ${orderId}:`, error.message);
    throw error;
  }
}

// List all simulations
export function listSimulations(limit = 20) {
  const simulations = loadSimulations();
  return simulations.slice(-limit).reverse();
}

// Get latest simulation
export function getLatestSimulation() {
  const simulations = loadSimulations();
  return simulations.length > 0 ? simulations[simulations.length - 1] : null;
}

// Clear simulation history
export function clearSimulations() {
  try {
    fs.writeFileSync(SIMULATIONS_FILE, "[]");
    console.log("ðŸ—‘ï¸  Simulation history cleared");
    return true;
  } catch (error) {
    console.error("âŒ Failed to clear simulations:", error.message);
    return false;
  }
}

// Get simulation statistics
export function getSimulationStats() {
  const simulations = loadSimulations();
  
  const successful = simulations.filter(s => s.success).length;
  const failed = simulations.filter(s => !s.success).length;
  
  const deliveryMethods = {};
  simulations.forEach(s => {
    if (s.delivery) {
      const method = s.delivery.service || s.delivery.carrier || "unknown";
      deliveryMethods[method] = (deliveryMethods[method] || 0) + 1;
    }
  });

  return {
    total: simulations.length,
    successful,
    failed,
    successRate: simulations.length > 0 ? ((successful / simulations.length) * 100).toFixed(1) : 0,
    deliveryMethods,
    latest: getLatestSimulation(),
  };
}
